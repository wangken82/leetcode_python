solution 1: use bell-more.  repeat N times, N=node.  mark each node as infiniteï¼Œfor [u,v,time]  if result[v] >result[u]+time,
then result[v] = result[u]+time.  There is a limitation for bell-more, if there is a cycle with negative sum, then could not use

from collections import defaultdict
class Solution:
    def networkDelayTime(self, times: List[List[int]], N: int, K: int) -> int:
        result = [float('inf')] * (N+1)
        result[K] = 0
        #bell-more need repeat N times. N=node. if there is a cycle with negative sum, then could not use bell-more
        for i in range(N):
            for time in times:
                u = time[0]
                v = time[1]
                val = time[2]
                #print(result)
                #print(v)
                if result[v] > result[u] + val:
                    result[v] = result[u] + val
        maxval = 0
        for i in range(1,len(result)):
            if result[i] == float('inf'):
                return -1
            else:
                maxval = max(maxval,result[i])
        
        return maxval
